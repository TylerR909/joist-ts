"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[405],{5318:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>u});var n=a(7378);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},m=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=d(a),u=o,h=c["".concat(s,".").concat(u)]||c[u]||p[u]||i;return a?n.createElement(h,r(r({ref:t},m),{},{components:a})):n.createElement(h,r({ref:t},m))}));function u(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=a.length,r=new Array(i);r[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var d=2;d<i;d++)r[d]=a[d];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},5543:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var n=a(5773),o=(a(7378),a(5318));const i={title:"Code Generation",sidebar_position:1},r=void 0,l={unversionedId:"goals/code-generation",id:"goals/code-generation",title:"Code Generation",description:"One of the primary ways Joist achieves ActiveRecord-level productivity is by generating the boilerplate part of domain models from the database schema.",source:"@site/docs/goals/code-generation.md",sourceDirName:"goals",slug:"/goals/code-generation",permalink:"/docs/goals/code-generation",draft:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/goals/code-generation.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Code Generation",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/docs/goals"},next:{title:"Avoiding N+1s",permalink:"/docs/goals/avoiding-n-plus-1s"}},s={},d=[{value:"Beautiful Domain Models",id:"beautiful-domain-models",level:2},{value:"What is Generated?",id:"what-is-generated",level:2},{value:"Evergreen Code Generation",id:"evergreen-code-generation",level:2},{value:"Custom Business Logic",id:"custom-business-logic",level:3},{value:"Declarative Customizations (TODO)",id:"declarative-customizations-todo",level:3},{value:"Pros/Cons",id:"proscons",level:2},{value:"Why Schema First?",id:"why-schema-first",level:2}],m={toc:d};function p(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"One of the primary ways Joist achieves ActiveRecord-level productivity is by generating the boilerplate part of domain models from the database schema."),(0,o.kt)("h2",{id:"beautiful-domain-models"},"Beautiful Domain Models"),(0,o.kt)("p",null,"To see this in action, for an ",(0,o.kt)("inlineCode",{parentName:"p"},"authors")," table, in Joist the initial ",(0,o.kt)("inlineCode",{parentName:"p"},"Author.ts")," domain model is as clean & simple as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'import { AuthorCodegen } from "./entities";\n\nexport class Author extends AuthorCodegen {}\n')),(0,o.kt)("p",null,"And that's it."),(0,o.kt)("p",null,"This is very similar to Rails ActiveRecord, where Joist automatically adds all the columns to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Author")," class for free, without having to re-type them in your domain object."),(0,o.kt)("p",null,"It does this for:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Primitive columns, i.e. ",(0,o.kt)("inlineCode",{parentName:"li"},"first_name")," can be set via ",(0,o.kt)("inlineCode",{parentName:"li"},'author.firstName = "bob"')),(0,o.kt)("li",{parentName:"ul"},"Foreign key columns, i.e. ",(0,o.kt)("inlineCode",{parentName:"li"},"book.author_id")," can be set via ",(0,o.kt)("inlineCode",{parentName:"li"},"book.author.set(...)"),", and"),(0,o.kt)("li",{parentName:"ul"},"Foreign key collections, i.e. ",(0,o.kt)("inlineCode",{parentName:"li"},"Author.books")," can be loaded via ",(0,o.kt)("inlineCode",{parentName:"li"},"await author.books.load()"),"."),(0,o.kt)("li",{parentName:"ul"},"One-to-one relations, many-to-many collections, etc.")),(0,o.kt)("p",null,"These columns/fields are added to the ",(0,o.kt)("inlineCode",{parentName:"p"},"AuthorCodegen.ts")," file, which looks (redacted for clarity) something like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'// This is all generated code\nexport abstract class AuthorCodegen extends BaseEntity {\n  readonly books = hasMany(bookMeta, "books", "author", "author_id");\n  readonly publisher = hasOne(publisherMeta, "publisher", "authors");\n\n  // ...\n\n  get id(): AuthorId | undefined { ... }\n  get firstName(): string { ... }\n  set firstName(firstName: string) { ...}\n}\n')),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Note that, while ActiveRecord leverages Ruby's runtime meta-programming to add getter & setters when your program starts up, Joist does this via build-time code generation (i.e. by running a ",(0,o.kt)("inlineCode",{parentName:"p"},"npm run joist-codegen")," command)."),(0,o.kt)("p",{parentName:"admonition"},"This approach allows the generated types to be seen by the TypeScript compiler and IDEs, and so provides your codebase a type-safe view of your database.")),(0,o.kt)("h2",{id:"what-is-generated"},"What is Generated?"),(0,o.kt)("p",null,"When running ",(0,o.kt)("inlineCode",{parentName:"p"},"npm run joist-codegen"),", Joist will examine the database schema and generate:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"For each entity table (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"authors"),'), an entity "codegen" file (',(0,o.kt)("inlineCode",{parentName:"p"},"AuthorCodegen.ts"),")"),(0,o.kt)("p",{parentName:"li"},"This file is written out ",(0,o.kt)("strong",{parentName:"p"},"every time")," and contains the boilerplate code that can be deterministically inferred from the database schema, from example:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Fields for all primitive columns"),(0,o.kt)("li",{parentName:"ul"},"Fields for all relations (references like ",(0,o.kt)("inlineCode",{parentName:"li"},"Book.author")," and collections like ",(0,o.kt)("inlineCode",{parentName:"li"},"Author.books"),")"),(0,o.kt)("li",{parentName:"ul"},"Basic auto-generated validation rules (e.g. from not null constraints)"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},'For each entity table, an entity "working" file (',(0,o.kt)("inlineCode",{parentName:"p"},"Author.ts"),")"),(0,o.kt)("p",{parentName:"li"},"This file is written out ",(0,o.kt)("strong",{parentName:"p"},"only once")," and is where custom business logic and validation rules can go, without it being over-written by the next time ",(0,o.kt)("inlineCode",{parentName:"p"},"joist-codegen")," runs.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"For each entity table, a factory file (",(0,o.kt)("inlineCode",{parentName:"p"},"Author.factories.ts"),")"),(0,o.kt)("p",{parentName:"li"},'This file provides tests with a succinct "one-liner" way to get a valid entity.')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"A ",(0,o.kt)("inlineCode",{parentName:"p"},"metadata.ts")," file with schema information."))),(0,o.kt)("h2",{id:"evergreen-code-generation"},"Evergreen Code Generation"),(0,o.kt)("p",null,"Joist's code generation runs continually (although currently invoked by hand, i.e. individual ",(0,o.kt)("inlineCode",{parentName:"p"},"npm run joist-codegen")," commands), after every migration/schema change, so your domain objects will always 1-to-1 match your schema, without having to worry about keeping the two in sync."),(0,o.kt)("h3",{id:"custom-business-logic"},"Custom Business Logic"),(0,o.kt)("p",null,"Even though Joist's code generation runs continually, it only touches the ",(0,o.kt)("inlineCode",{parentName:"p"},"Author.ts")," once."),(0,o.kt)("p",null,"After that, all of Joist's updates are made only to the separate ",(0,o.kt)("inlineCode",{parentName:"p"},"AuthorCodegen.ts")," file."),(0,o.kt)("p",null,"This makes ",(0,o.kt)("inlineCode",{parentName:"p"},"Author.ts"),' a safe space to add any custom business logic you might need, separate from the boilerplate of the various getters, setters, and relations that are isolated into "codegen" base class, and always overwritten.'),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"/docs/modeling/lifecycle-hooks"},"Lifecycle Hooks")," and ",(0,o.kt)("a",{parentName:"p",href:"/docs/modeling/derived-fields"},"Derived Fields")," for examples of how to add business logic."),(0,o.kt)("h3",{id:"declarative-customizations-todo"},"Declarative Customizations (TODO)"),(0,o.kt)("p",null,"If you do need to customize how a column is mapped, Joist ",(0,o.kt)("em",{parentName:"p"},"should")," (these are not implemented yet) have two levers to pull:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Declare a schema-wide rule based on the column's type and/or naming convention"),(0,o.kt)("p",{parentName:"li"},"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"joist-config.json")," config file, define all ",(0,o.kt)("inlineCode",{parentName:"p"},"timestampz")," columns should be mapped as type ",(0,o.kt)("inlineCode",{parentName:"p"},"MyCustomDateTime"),"."),(0,o.kt)("p",{parentName:"li"},"This would be preferable to per-column configuration/annotations because you could declare the rule once, and have it apply to all applicable columns in your schema.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Declare a specific user type for a column."),(0,o.kt)("p",{parentName:"li"},"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"joist-config.json")," config file, define the column's specific user type."))),(0,o.kt)("h2",{id:"proscons"},"Pros/Cons"),(0,o.kt)("p",null,"This approach (continual, verbatim mapping of the database schema to your object model) generally assumes you have a modern/pleasant schema to work with, and you don't need your object model to look dramatically different from your database tables."),(0,o.kt)("p",null,"Joist's assertion is that this strict 1-1 mapping is a feature, because it should largely help avoid the ",(0,o.kt)("a",{parentName:"p",href:"https://blog.codinghorror.com/object-relational-mapping-is-the-vietnam-of-computer-science/"},"horror stories of ORMs"),", where the ORM is asked to do non-trivial translation between a database schema and object model that are fundamentally at odds."),(0,o.kt)("h2",{id:"why-schema-first"},"Why Schema First?"),(0,o.kt)("p",null,'Joist\'s approach is "schema first", i.e. we first declare the database schema, and then generate the domain model from the database schema.'),(0,o.kt)("p",null,'Along with "schema-first", there generally three approaches to domain model/database mapping:'),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Schema-first (generate code from the schema database, like Joist)"),(0,o.kt)("li",{parentName:"ol"},"Code-first (generate the schema from the code, i.e. from ",(0,o.kt)("inlineCode",{parentName:"li"},"@Column")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"@ManyToOne")," annotations in the domain model)"),(0,o.kt)("li",{parentName:"ol"},"No automatic generation either way, just map the two by hand")),(0,o.kt)("p",null,'Joist\'s assertion is that schema-first is the most pragmatic, b/c the database really is the "source of truth" for the data, and that code-first schema-generation does not scale once you have to production data that needs to be migrated that can sometimes, but not ',(0,o.kt)("em",{parentName:"p"},"always"),", be migrated automatically."),(0,o.kt)("p",null,'(That said, code-first schema generates have gotten a lot more robust, so if you want to use a "model-first" schema management / migration library, that\'s fine; you could define your model in that, use it to apply/manage your database schema, and then generate your Joist domain model from the database schema.)'))}p.isMDXComponent=!0}}]);