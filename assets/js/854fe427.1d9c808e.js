"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[954],{5318:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7378);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(n),m=i,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||r;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4958:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var a=n(5773),i=(n(7378),n(5318));const r={title:"Loading Entities",sidebar_position:2},o=void 0,l={unversionedId:"features/loading-entities",id:"features/loading-entities",title:"Loading Entities",description:"Joist has several ways to load entities, and which to use depends on how much control you need over the query.",source:"@site/docs/features/loading-entities.md",sourceDirName:"features",slug:"/features/loading-entities",permalink:"/docs/features/loading-entities",draft:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/features/loading-entities.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Loading Entities",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Entity Manager",permalink:"/docs/features/entity-manager"},next:{title:"Find Queries",permalink:"/docs/features/queries-find"}},s={},u=[{value:"Approaches",id:"approaches",level:2},{value:"1. Object Graph Navigation",id:"1-object-graph-navigation",level:3},{value:"2. Find Queries",id:"2-find-queries",level:3},{value:"3. Other Query Builders",id:"3-other-query-builders",level:3},{value:"<code>buildQuery</code>",id:"buildquery",level:4}],p={toc:u};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Joist has several ways to load entities, and which to use depends on how much control you need over the query."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Joist's primary focus is not \"",(0,i.kt)("em",{parentName:"p"},"never"),' having to hand-write SQL", so it is not a full-fledged query builder (like ',(0,i.kt)("a",{parentName:"p",href:"https://knexjs.org/"},"Knex")," or ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/koskimas/kysely"},"Kysely"),"); instead it focuses on robust domain modeling, with validation rules, reactive derived values, etc."),(0,i.kt)("p",{parentName:"admonition"},"So it's expected to, for advanced/complicated queries, occasionally use a 3rd party query builder in addition to Joist, as covered in Approach 3.")),(0,i.kt)("h2",{id:"approaches"},"Approaches"),(0,i.kt)("p",null,"Loading entities is a core feature of ORMs, and Joist supports several ways of doing this:"),(0,i.kt)("h3",{id:"1-object-graph-navigation"},"1. Object Graph Navigation"),(0,i.kt)("p",null,'This is the bread & butter of ORMs, and involves just "walking the graph" from some entity you already have, to other entities that are related to it. Examples are:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// Calling .load() methods directly\nconst author = await book.author.load();\n// Using a lens\nconst reviews = await publisher.load(p => p.books.reviews);\n// Using populate + gets\nconst loaded = author.populate({ books: "reviews" });\nloaded.books.get.flatMap(b => b.reviews.get);\n')),(0,i.kt)("p",null,"This pattern will likely be ",(0,i.kt)("strong",{parentName:"p"},"~90% of the queries"),' in your app, and are so pervasive/ergonomic that you likely won\'t even think of them as "making SQL queries".'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Pro: The most succinct way of loading entities."),(0,i.kt)("li",{parentName:"ul"},"Pro: Joist guarantees these will not N+1, even if called in a loop."),(0,i.kt)("li",{parentName:"ul"},"Pro: Works with non-database/domain model-only relations like Joist's ",(0,i.kt)("inlineCode",{parentName:"li"},"hasOneDerived"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"hasOneThrough"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"AsyncProperties"),", etc."),(0,i.kt)("li",{parentName:"ul"},"Con: Generally object graph navigation loads all entities within the sub-graph you're walking, i.e. you can't say \"return only ",(0,i.kt)("em",{parentName:"li"},"out of stock"),' books" (see ',(0,i.kt)("inlineCode",{parentName:"li"},"find")," queries next)")),(0,i.kt)("h3",{id:"2-find-queries"},"2. Find Queries"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"EntityManager.find")," queries are a middle-ground that allow database-side filtering of rows, and so return only a subset of data (instead of the full subgraph like approach 1). Examples are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const r1 = await em.find(Book, { author: { firstName: "b1" } });\nconst r2 = await em.find(Publisher, { authors: { firstName: "b1" } });\nconst r3 = await em.find(Author, { firstName: { like: "%a%" } });\nconst r4 = await em.find(Author, { publisher: p1 });\n')),(0,i.kt)("p",null,"If object graph navigation is ~80% of your application's queries (because they are all implicit), ",(0,i.kt)("inlineCode",{parentName:"p"},"em.find")," queries will likely be ",(0,i.kt)("strong",{parentName:"p"},"~15% of your queries"),"."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"./queries-find"},"Find Queries")," for more documentation and examples."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Pro: Still succinct because joins are implicit in the object literal"),(0,i.kt)("li",{parentName:"ul"},"Pro: Supports ",(0,i.kt)("inlineCode",{parentName:"li"},"WHERE"),"-based filtering/returning a subset of entities"),(0,i.kt)("li",{parentName:"ul"},"Pro: N+1 safe even when called in a loop"),(0,i.kt)("li",{parentName:"ul"},"Con: Cannot use domain model-level relations like Joist's ",(0,i.kt)("inlineCode",{parentName:"li"},"hasOneDerived"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"hasOneThrough"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"AsyncProperties"),", etc."),(0,i.kt)("li",{parentName:"ul"},"Con: Loads only full entities, not cross-table aggregates/group bys/etc.")),(0,i.kt)("h3",{id:"3-other-query-builders"},"3. Other Query Builders"),(0,i.kt)("p",null,"For queries that grow outside what ",(0,i.kt)("inlineCode",{parentName:"p"},"em.find")," can provide, i.e. ",(0,i.kt)("strong",{parentName:"p"},"the last ~5% of your application's queries")," that are truly custom, then it's perfectly fine to use a 3rd-party query builder like ",(0,i.kt)("a",{parentName:"p",href:"https://knexjs.org/"},"Knex")," or ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/koskimas/kysely"},"Kysely"),"."),(0,i.kt)("p",null,"Knex would be a natural choice, because Joist uses Knex as an internal dependency, but Kysely would be fine too."),(0,i.kt)("p",null,"In particular, any queries that need to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Group bys/aggregates"),(0,i.kt)("li",{parentName:"ul"},"Select custom fragments of data (not just an entity)")),(0,i.kt)("p",null,"Are best done via Knex or Kysely."),(0,i.kt)("h4",{id:"buildquery"},(0,i.kt)("inlineCode",{parentName:"h4"},"buildQuery")),(0,i.kt)("p",null,"Joist provides a ",(0,i.kt)("inlineCode",{parentName:"p"},"buildQuery")," method that allows blending approaches 2 and 3: you can pass an ",(0,i.kt)("inlineCode",{parentName:"p"},"em.find"),"-style join literal to ",(0,i.kt)("inlineCode",{parentName:"p"},"buildQuery")," (with either inline or complex conditions), and get back a Knex ",(0,i.kt)("inlineCode",{parentName:"p"},"QueryBuilder")," with all the joins and conditions added, to which you can do your own further joins or filters."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const query = buildQuery(knex, Book, {\n  where: { author: [a1, a2] },\n});\n// Use knex methods to continue building the query\nquery.whereNotNull("parent_bill_id");\n// Then load the entities with the customizing query\nconst books = await em.loadFromQuery(Book, query);\n')),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"These three options all focus on loading ",(0,i.kt)("em",{parentName:"p"},"entities"),", which your code will then iterate over to perform business/view logic."),(0,i.kt)("p",{parentName:"admonition"},'If you need to load bespoke, non-entity fragments of data across several tables (i.e. with aggregates/group bys/etc.), that is currently not a feature that Joist provides, so you must use a separate raw query builder, as per the "option 3" in the above list.')))}d.isMDXComponent=!0}}]);