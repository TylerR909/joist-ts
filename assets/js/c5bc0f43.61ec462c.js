"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[761],{5318:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var o=a(7378);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,o,n=function(e,t){if(null==e)return{};var a,o,n={},i=Object.keys(e);for(o=0;o<i.length;o++)a=i[o],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)a=i[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=o.createContext({}),p=function(e){var t=o.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=p(a),m=n,k=u["".concat(s,".").concat(m)]||u[m]||h[m]||i;return a?o.createElement(k,l(l({ref:t},d),{},{components:a})):o.createElement(k,l({ref:t},d))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,l=new Array(i);l[0]=u;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:n,l[1]=r;for(var p=2;p<i;p++)l[p]=a[p];return o.createElement.apply(null,l)}return o.createElement.apply(null,a)}u.displayName="MDXCreateElement"},7059:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var o=a(5773),n=(a(7378),a(5318));const i={title:"Avoiding N+1s",sidebar_position:2},l=void 0,r={unversionedId:"goals/avoiding-n-plus-1s",id:"goals/avoiding-n-plus-1s",title:"Avoiding N+1s",description:"Joist is built on Facebook's dataloader library, which means Joist avoids N+1s in a fundamental, systematic way that just works.",source:"@site/docs/goals/avoiding-n-plus-1s.md",sourceDirName:"goals",slug:"/goals/avoiding-n-plus-1s",permalink:"/docs/goals/avoiding-n-plus-1s",draft:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/goals/avoiding-n-plus-1s.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Avoiding N+1s",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Code Generation",permalink:"/docs/goals/code-generation"},next:{title:"Load-Safe Relations",permalink:"/docs/goals/load-safe-relations"}},s={},p=[{value:"N+1s: Lazy Loading in a Loop",id:"n1s-lazy-loading-in-a-loop",level:2},{value:"Type-Safe Preloading",id:"type-safe-preloading",level:2},{value:"Longer Background",id:"longer-background",level:2},{value:"Common/Tedious Pitfall",id:"commontedious-pitfall",level:3},{value:"Saved By the Event Loop",id:"saved-by-the-event-loop",level:3},{value:"Control Flow",id:"control-flow",level:3},{value:"N+1-Safe GraphQL Resolvers",id:"n1-safe-graphql-resolvers",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Graph Navigation",id:"graph-navigation",level:3},{value:"Find Queries",id:"find-queries",level:3}],d={toc:p};function h(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,o.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"Joist is built on Facebook's ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/graphql/dataloader"},"dataloader")," library, which means Joist avoids N+1s in a fundamental, systematic way that just works."),(0,n.kt)("p",null,"This solid foundation comes Joist's roots as an ORM for GraphQL backends, which are particularly prone to N+1s (see section below), but is a boon to any system (REST, GRPC, etc.) working with relational data. "),(0,n.kt)("h2",{id:"n1s-lazy-loading-in-a-loop"},"N+1s: Lazy Loading in a Loop"),(0,n.kt)("p",null,'As a short explanation, the term "N+1" is what ',(0,n.kt)("em",{parentName:"p"},"can")," happen for code that looks like:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-typescript"},'// Get an author and their books\nconst author = await em.load(Author, "a:1");\nconst books = await author.books.load();\n\n// Do something with each book\nawait Promise.all(books.map(async (book) => {\n  // Now I want each book\'s reviews... in Joist this does _not_ N+1\n  const reviews = await book.reviews.load();\n}));\n')),(0,n.kt)("p",null,"Without Joist (or a similar Dataloader-ish approach), the risk is each ",(0,n.kt)("inlineCode",{parentName:"p"},"book.reviews.load()")," causes its own ",(0,n.kt)("inlineCode",{parentName:"p"},"SELECT * FROM book_reviews WHERE book_id = ..."),". I.e. the 1st loop calls ",(0,n.kt)("inlineCode",{parentName:"p"},"SELECT ... WHERE book_id = 1"),", the 2nd loop calls ",(0,n.kt)("inlineCode",{parentName:"p"},"SELECT ... WHERE book_id = 2"),", etc., such that if we have ",(0,n.kt)("inlineCode",{parentName:"p"},"N")," books, we will make ",(0,n.kt)("inlineCode",{parentName:"p"},"N")," SQL queries, one for each book id."),(0,n.kt)("p",null,"If we count the initial ",(0,n.kt)("inlineCode",{parentName:"p"},"SELECT * FROM books WHERE author_id = 1")," query as ",(0,n.kt)("inlineCode",{parentName:"p"},"1"),", this means we've made ",(0,n.kt)("inlineCode",{parentName:"p"},"N + 1")," queries to process each of the author's books, hence the term N+1."),(0,n.kt)("p",null,"However, with Joist the above code will issue only ",(0,n.kt)("strong",{parentName:"p"},"three queries"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"-- first em.load\nSELECT * FROM authors WHERE id = 1;\n-- author.books.load()\nSELECT * FROM books WHERE author_id = 1;\n-- All of the book.reviews.load() combined into 1 query\nSELECT * FROM book_reviews WHERE book_id IN (1, 2, 3, ...);\n")),(0,n.kt)("p",null,"This N+1 prevention works not only in our 3-line ",(0,n.kt)("inlineCode",{parentName:"p"},"await Promise.all"),' example, but also works in complex codepaths where the business logic of "process each book" (and any lazy loading it might trigger) is spread out across helper methods, validation rules, entity lifecycle hooks, etc.'),(0,n.kt)("h2",{id:"type-safe-preloading"},"Type-Safe Preloading"),(0,n.kt)("p",null,"While the 1st snippet shows that Joist avoids N+1s in ",(0,n.kt)("inlineCode",{parentName:"p"},"async")," / ",(0,n.kt)("inlineCode",{parentName:"p"},"Promise.all"),"-heavy code, Joist also supports populate hints, which not only ",(0,n.kt)("strong",{parentName:"p"},"preload the data")," but also ",(0,n.kt)("strong",{parentName:"p"},"change the types to allow non-async access"),". "),(0,n.kt)("p",null,"With Joist, the above code can be rewritten (code golf-d) as:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-typescript"},'// Get an author and their books _and_ the books\' reviews\nconst author = await em.load(Author, "a:1", { books: "reviews" });\n// Do something with each book _and_ its reviews ... with no awaits!\nauthor.books.get.map((book) => {\n  // The `.get` method is available here only b/c we passed "reviews" to em.load\n  const reviews = book.reviews.get;\n});\n')),(0,n.kt)("p",null,"And it has exactly the same runtime semantics as the previous ",(0,n.kt)("inlineCode",{parentName:"p"},"async/await"),"-based code: the ",(0,n.kt)("strong",{parentName:"p"},"same three queries"),' are issued for both "with populate hints" and "without populate hints" code.'),(0,n.kt)("p",null,"See ",(0,n.kt)("a",{parentName:"p",href:"/docs/goals/load-safe-relations"},"Load-Safe Relations")," for more information about this feature, however we point it out here because while populate hints are great for writing non-async code & avoiding N+1s (other ORMs like ActiveRecord use them), in Joist ",(0,n.kt)("strong",{parentName:"p"},"populate hints are supported but ",(0,n.kt)("em",{parentName:"strong"},"not required")," to avoid N+1s"),"."),(0,n.kt)("p",null,"This is key, because in a sufficiently large/complex codebase, it can be ",(0,n.kt)("strong",{parentName:"p"},"extremely hard to know ahead of time")," exactly the right populate hint(s) that an endpoint should use to preload its data in an N+1 safe manner."),(0,n.kt)("p",null,"With Joist, you don't have to worry anymore: if you use populate hints, that's great, you won't have N+1s. But if you end up with business logic (helper methods, validation rules, etc.) being called in an ",(0,n.kt)("inlineCode",{parentName:"p"},"async")," loop, ",(0,n.kt)("strong",{parentName:"p"},"it will still be fine"),', and not N+1, because in Joist both populate hints & "old-school" ',(0,n.kt)("inlineCode",{parentName:"p"},"async/await")," access are built on top of the same Dataloader-based, N+1-safe core."),(0,n.kt)("h2",{id:"longer-background"},"Longer Background"),(0,n.kt)("h3",{id:"commontedious-pitfall"},"Common/Tedious Pitfall"),(0,n.kt)("p",null,'N+1s have fundamentally plagued ORMs, in any language, because the defacto ORM approach of "relations are just methods on an object" (i.e. ',(0,n.kt)("inlineCode",{parentName:"p"},"author1.getBooks()")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"book1.getAuthor()"),") causes a ",(0,n.kt)("strong",{parentName:"p"},"leaky abstraction")," because the method calls are not super-cheap in-memory accesses (like most method calls), but instead actually expensive I/O calls."),(0,n.kt)("p",null,"Methods that issue I/O calls are powerful, however they are almost too ergonomic: it's very natural for programmers to, given a list of objects, loop over those objects and access their methods."),(0,n.kt)("p",null,"This is an extremely common pattern (looping over objects and calling their methods), which means in most ORMs N+1s are also extremely common, without careful planning (i.e. manually-maintained preload hints)."),(0,n.kt)("p",null,"For example, in Rails ActiveRecord, N+1s happen by default, and the programmer needs to tell ActiveRecord ahead of time which collections to preload:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ruby"},'author = Author.find_by_id("1");\n# The `include(:reviews)` means reviews are fetched before the `for` loop\nbooks = Book.find({ author_id: author.id }).include(:reviews)\nbooks.each do |book|\n  # Now access the collection, and it\'s already in-memory.\n  # Without `include(:reviews)` this would still work but _silently N+1_\n  reviews = book.reviews.length;\nend\n')),(0,n.kt)("p",null,"This ",(0,n.kt)("inlineCode",{parentName:"p"},"include(:reviews)")," resolves the performance issue, but relies on the programmer knowing what data will be accessed in loops ahead of time. This is possible, but as a codebase grows it becomes a tedious game of whack-a-mole, as the default behavior is inherently unsafe. "),(0,n.kt)("h3",{id:"saved-by-the-event-loop"},"Saved By the Event Loop"),(0,n.kt)("p",null,"Joist is able to avoid N+1s ",(0,n.kt)("strong",{parentName:"p"},"without preload hints")," by leveraging Facebook's ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/graphql/dataloader"},"dataloader")," library to automatically batch multiple ",(0,n.kt)("inlineCode",{parentName:"p"},"load")," operations into single SQL statements."),(0,n.kt)("p",null,"Dataloader leverages JavaScript's synchronous/single-thread model, which is where when JavaScript evaluates the ",(0,n.kt)("inlineCode",{parentName:"p"},"book.reviews.load()")," method inside of ",(0,n.kt)("inlineCode",{parentName:"p"},"books.map"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-typescript"},"await Proimse.all(books.map(async (book) => {\n  const reviews = await book.reviews.load();\n}));\n")),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"book.reviews.load")," method is fundamentally not allowed make an immediate SQL call, because it would block the event loop."),(0,n.kt)("p",null,"Instead, the ",(0,n.kt)("inlineCode",{parentName:"p"},"load")," method is forced to return a ",(0,n.kt)("inlineCode",{parentName:"p"},"Promise"),", handle the I/O off the thread, and then later return the ",(0,n.kt)("inlineCode",{parentName:"p"},"reviews")," that have been loaded."),(0,n.kt)("p",null,"And so the ",(0,n.kt)("em",{parentName:"p"},"actual"),' "immediate next thing" that this code does is not "make a SQL call for book1\'s reviews", but instead is the next iteration of ',(0,n.kt)("inlineCode",{parentName:"p"},"books.map"),", i.e. get ",(0,n.kt)("inlineCode",{parentName:"p"},"book 2")," and asks for its ",(0,n.kt)("inlineCode",{parentName:"p"},"book.reviews.load()")," as well."),(0,n.kt)("p",null,'Ironically, this forced "nothing can block" model, that for years was the bane of JavaScript due to the pre-',(0,n.kt)("inlineCode",{parentName:"p"},"Promise")," callback hell it caused, gives Joist (via dataloader) an opportunity to wait just a ",(0,n.kt)("em",{parentName:"p"},"little bit"),", until all of the ",(0,n.kt)("inlineCode",{parentName:"p"},"book.reviews.load()"),' have been "asked for", and the ',(0,n.kt)("inlineCode",{parentName:"p"},"books.map")," iteration is finished, to only then see that \"ah, we've been asked to do 10 ",(0,n.kt)("inlineCode",{parentName:"p"},"book.reviews.load"),", let's do those as a single SQL statement\", and execute a single SQL statement like:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM book_reviews WHERE book_id IN (1, 2, 3, ..., 10);\n")),(0,n.kt)("h3",{id:"control-flow"},"Control Flow"),(0,n.kt)("p",null,'It is a little esoteric, but dataloader implements this by automatically managing "flush" events in JavaScript\'s event loop. Specifically, the event loop execution will look like (each "Tick" is a synchronous execution of logic on the event loop):'),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Tick 1, call ",(0,n.kt)("inlineCode",{parentName:"li"},"books.map")," for each book, and synchronously",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"For book 1, call ",(0,n.kt)("inlineCode",{parentName:"li"},"load"),', there is no existing "flush" event, so dataloader creates one at the end of the queue, with ',(0,n.kt)("inlineCode",{parentName:"li"},"book:1")," in it"),(0,n.kt)("li",{parentName:"ul"},"For book 2, call ",(0,n.kt)("inlineCode",{parentName:"li"},"load"),', see there is already a queued "flush" event, so add ',(0,n.kt)("inlineCode",{parentName:"li"},"book:2")," to it,"),(0,n.kt)("li",{parentName:"ul"},"For book ",(0,n.kt)("inlineCode",{parentName:"li"},"N"),", call ",(0,n.kt)("inlineCode",{parentName:"li"},"load"),', see there is already a queued "flush" event, so add ',(0,n.kt)("inlineCode",{parentName:"li"},"book:N")," to it"))),(0,n.kt)("li",{parentName:"ul"},'Tick 2, evaluate the "flush" event',(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},'Tell Joist "load all 10 books"'),(0,n.kt)("li",{parentName:"ul"},"Joist issues a single SQL statement"))),(0,n.kt)("li",{parentName:"ul"},'Tick 3, SQL statement resolves, Joist tells dataloader "okay, here are the reviews for each of the 10 books"',(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Resolve book 1's promise with its reviews"),(0,n.kt)("li",{parentName:"ul"},"Resolve book 2's promise with its reviews"),(0,n.kt)("li",{parentName:"ul"},"Resolve book ",(0,n.kt)("inlineCode",{parentName:"li"},"N"),"'s promise with its reviews"))),(0,n.kt)("li",{parentName:"ul"},"Tick 4, continue book 1's ",(0,n.kt)("inlineCode",{parentName:"li"},"async")," function, now with ",(0,n.kt)("inlineCode",{parentName:"li"},"reviews")," populated"),(0,n.kt)("li",{parentName:"ul"},"Tick 5, continue book 2's ",(0,n.kt)("inlineCode",{parentName:"li"},"async")," function, now with ",(0,n.kt)("inlineCode",{parentName:"li"},"reviews")," populated"),(0,n.kt)("li",{parentName:"ul"},"...")),(0,n.kt)("h2",{id:"n1-safe-graphql-resolvers"},"N+1-Safe GraphQL Resolvers"),(0,n.kt)("p",null,"Joist's auto-batching works for any ",(0,n.kt)("inlineCode",{parentName:"p"},"em.load")," calls (or lazy-load calls ",(0,n.kt)("inlineCode",{parentName:"p"},"author.books.load()"),", etc.) that happen synchronously within a tick of the event loop."),(0,n.kt)("p",null,"This means that auto-batching works for either simple/obvious cases like calling ",(0,n.kt)("inlineCode",{parentName:"p"},"book.reviews.load()")," in ",(0,n.kt)("inlineCode",{parentName:"p"},"books.map(book => ...)")," lambda, or ",(0,n.kt)("strong",{parentName:"p"},"disparately across separate methods")," that are still invoked (essentially) simultaneously, which is exactly what happens with GraphQL resolvers."),(0,n.kt)("p",null,"For example, let's say a GraphQL client has issued a query like:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"query {\n  authors(id: 1) {\n    books {\n      reviews {\n        id\n        name  \n      }  \n    }  \n  }\n}\n")),(0,n.kt)("p",null,"We might implement our ",(0,n.kt)("inlineCode",{parentName:"p"},"books.reviews")," resolver like:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-typescript"},"const booksResolver = {\n  async reviews(bookId, args, ctx) {\n    const book = await ctx.em.load(Book, bookId);\n    return await book.reviews.load();\n  }\n}\n")),(0,n.kt)("p",null,"And, the way the GraphQL resolver pattern works, the GraphQL runtime will call the ",(0,n.kt)("inlineCode",{parentName:"p"},"booksResolver.reviews(1)"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"booksResolver.reviews(2)"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"booksResolver.reviews(3)"),", etc. method for each of the books returning from our query."),(0,n.kt)("p",null,"This looks like it could be an N+1, however because each of the ",(0,n.kt)("inlineCode",{parentName:"p"},"reviews(1)"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"reviews(2)"),', etc. calls has happened within a single tick of the event loop, the dataloader "flush" event will automatically kick-in and ask Joist to look all of the reviews as a single SQL call.'),(0,n.kt)("admonition",{type:"tip"},(0,n.kt)("p",{parentName:"admonition"},"Joist is GraphQL agnostic; you can use a different API layer, like REST or GRPC, we are just using GraphQL as an example due to its N+1 prone nature.")),(0,n.kt)("h2",{id:"how-it-works"},"How It Works"),(0,n.kt)("p",null,"There are two primary components to Joist's batching:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Graph navigation, and"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("inlineCode",{parentName:"li"},"em.find")," queries")),(0,n.kt)("h3",{id:"graph-navigation"},"Graph Navigation"),(0,n.kt)("p",null,"To avoid N+1s during graph navigation (using methods ",(0,n.kt)("inlineCode",{parentName:"p"},"author.books.load")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"book.author.load")," to lazy load data), Joist maintains a dataloader per relation/per edge. For example if you do:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"await author1.books.load()")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"await author2.books.load()")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"await author3.books.load()"))),(0,n.kt)("p",null,"In a loop, the ",(0,n.kt)("inlineCode",{parentName:"p"},"Author.books")," o2m relation has a dataloader that collects ",(0,n.kt)("inlineCode",{parentName:"p"},"author1"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"author2"),", and ",(0,n.kt)("inlineCode",{parentName:"p"},"author3")," entities in a list and then issues a SQL single statement for books with ",(0,n.kt)("inlineCode",{parentName:"p"},"WHERE author_id IN (1, 2, 3)"),"."),(0,n.kt)("p",null,"Joist has dataloader implementations for all the core relations involved in graph navigation: o2m, m2o, o2o, and m2m. Their implementations are straightforward and generally rock solid."),(0,n.kt)("h3",{id:"find-queries"},"Find Queries"),(0,n.kt)("p",null,"Besides graph navigation, Joist will also auto-batch ",(0,n.kt)("inlineCode",{parentName:"p"},"em.find")," queries, which are more adhoc ",(0,n.kt)("inlineCode",{parentName:"p"},"SELECT")," queries (see ",(0,n.kt)("a",{parentName:"p",href:"/docs/features/queries-find"},"Find Queries"),"). For example if you do:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},'await em.find(Author, { firstName: "a1", lastName: "l1" })')),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},'await em.find(Author, { firstName: "a2", lastName: "l2" })')),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},'await em.find(Author, { firstName: "a3", lastName: "l3" })'))),(0,n.kt)("p",null,"In a loop, then ",(0,n.kt)("inlineCode",{parentName:"p"},"em.find")," will batch any ",(0,n.kt)("inlineCode",{parentName:"p"},"SELECT")," statements that have the same joins and same filtering (essentially the same query structure) in a single statement that looks like:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"WITH _find (tag, arg1) AS (VALUES \n  (1, 'a1', 'l1'),\n  (2, 'a2', 'l2'),\n  (3, 'a3', 'l3')\n)\nSELECT * FROM authors a\nJOIN _find ON (a.first_name = _find.arg1 AND a.last_name = _find.arg2);\n")),(0,n.kt)("p",null,"This approach leverages the Common Table Expression (CTE) of inline values and extra ",(0,n.kt)("inlineCode",{parentName:"p"},"JOIN")," clause to essentially apply multiple ",(0,n.kt)("inlineCode",{parentName:"p"},"WHERE")," clauses at once. This is admittedly more esoteric than Joist's graph navigation dataloaders, but it achieves the goal of de-N+1-ing the queries."),(0,n.kt)("admonition",{type:"note"},(0,n.kt)("p",{parentName:"admonition"},"Joist's ",(0,n.kt)("inlineCode",{parentName:"p"},"em.find")," does not support ",(0,n.kt)("inlineCode",{parentName:"p"},"limit")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"offset")," because they cannot be applied with the ",(0,n.kt)("inlineCode",{parentName:"p"},"JOIN")," filtering approach. Instead, for ",(0,n.kt)("inlineCode",{parentName:"p"},"limit")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"offset"),"  you can use ",(0,n.kt)("inlineCode",{parentName:"p"},"em.findPaginated"),", although note that ",(0,n.kt)("inlineCode",{parentName:"p"},"findPaginated")," will not auto-batch, so you should avoid calling it in a loop.")))}h.isMDXComponent=!0}}]);