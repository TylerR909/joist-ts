"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[436],{5318:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var i=n(7378);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),m=a,k=c["".concat(s,".").concat(m)]||c[m]||u[m]||o;return n?i.createElement(k,r(r({ref:t},d),{},{components:n})):i.createElement(k,r({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6877:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var i=n(5773),a=(n(7378),n(5318));const o={title:"Configuration",slug:"/configuration",sidebar_position:2},r=void 0,l={unversionedId:"getting-started/configuration",id:"getting-started/configuration",title:"Configuration",description:"Joist prefers convention over configuration, but it still has some knobs to control its behavior.",source:"@site/docs/getting-started/configuration.md",sourceDirName:"getting-started",slug:"/configuration",permalink:"/docs/configuration",draft:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/getting-started/configuration.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Configuration",slug:"/configuration",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Schema Assumptions",permalink:"/docs/getting-started/schema-assumptions"},next:{title:"Overview",permalink:"/docs/goals"}},s={},p=[{value:"Codegen Configuration",id:"codegen-configuration",level:2},{value:"<code>databaseUrl</code>",id:"databaseurl",level:3},{value:"<code>idType</code>",id:"idtype",level:3},{value:"<code>contextType</code>",id:"contexttype",level:3},{value:"<code>entitiesDirectory</code>",id:"entitiesdirectory",level:3},{value:"<code>createFlushFunction</code>",id:"createflushfunction",level:3},{value:"<code>ignoredTables</code>",id:"ignoredtables",level:3},{value:"<code>timestampColumns</code>",id:"timestampcolumns",level:3},{value:"<code>codegenPlugins</code>",id:"codegenplugins",level:3},{value:"<code>entities</code>",id:"entities",level:3},{value:"<code>tag</code>",id:"tag",level:4},{value:"<code>tableName</code>",id:"tablename",level:4},{value:"<code>entities.orderBy</code>",id:"entitiesorderby",level:3},{value:"<code>entities.fields</code>",id:"entitiesfields",level:3},{value:"<code>entities.relations</code>",id:"entitiesrelations",level:3},{value:"Runtime Configuration",id:"runtime-configuration",level:2},{value:"Connection Pool",id:"connection-pool",level:3},{value:"Driver",id:"driver",level:3},{value:"IdAssigner",id:"idassigner",level:4},{value:"EntityManager",id:"entitymanager",level:3}],d={toc:p};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Joist prefers convention over configuration, but it still has some knobs to control its behavior."),(0,a.kt)("p",null,"The configuration is split into two sections:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Codegen config, used by ",(0,a.kt)("inlineCode",{parentName:"li"},"npm run joist-codegen")," during the code generation build step,"),(0,a.kt)("li",{parentName:"ol"},"Runtime config, used by ",(0,a.kt)("inlineCode",{parentName:"li"},"EntityManager")," at runtime to configure the database that Joist connects to.")),(0,a.kt)("p",null,"You can get started without any codegen config, and only some minimal runtime config."),(0,a.kt)("h2",{id:"codegen-configuration"},"Codegen Configuration"),(0,a.kt)("p",null,"The codegen configuration is controlled by a ",(0,a.kt)("inlineCode",{parentName:"p"},"./joist-config.json")," file, that ",(0,a.kt)("inlineCode",{parentName:"p"},"npm run joist-codegen")," will look for and automatically run."),(0,a.kt)("p",null,"A short, minimalistic example is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "entitiesDirectory": "./src/entities"\n}\n')),(0,a.kt)("p",null,"Each of the supported keys are described below. Note this is an exhaustive list, but all the keys are optional."),(0,a.kt)("h3",{id:"databaseurl"},(0,a.kt)("inlineCode",{parentName:"h3"},"databaseUrl")),(0,a.kt)("p",null,"This is the ",(0,a.kt)("em",{parentName:"p"},"build-time")," connection information for your database, e.g. it is only used when running ",(0,a.kt)("inlineCode",{parentName:"p"},"npm run joist-codegen"),", and won't be used for either your unit tests or production code, because it's assumed to have a hard-coded/local-only host/port/etc."),(0,a.kt)("p",null,"If this is not set, ",(0,a.kt)("inlineCode",{parentName:"p"},"npm run joist-codegen")," will also look for a ",(0,a.kt)("inlineCode",{parentName:"p"},"DATABASE_URL")," environment variable."),(0,a.kt)("h3",{id:"idtype"},(0,a.kt)("inlineCode",{parentName:"h3"},"idType")),(0,a.kt)("p",null,"Controls the type of the domain model's ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," properties, i.e. ",(0,a.kt)("inlineCode",{parentName:"p"},"Author.id")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"author1.id"),"."),(0,a.kt)("p",null,"Available values: ",(0,a.kt)("inlineCode",{parentName:"p"},"tagged-string"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"untagged-string"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"number"),"."),(0,a.kt)("p",null,"Joist's default behavior is ",(0,a.kt)("inlineCode",{parentName:"p"},"tagged-string")," which means the type of ",(0,a.kt)("inlineCode",{parentName:"p"},"Author.id")," will be a ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", and the value will be ",(0,a.kt)("inlineCode",{parentName:"p"},'"a:1"')," where ",(0,a.kt)("inlineCode",{parentName:"p"},"a"),' is the "tag" established for all ',(0,a.kt)("inlineCode",{parentName:"p"},"Author")," entities, and ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," is the numeric primary key value of that row."),(0,a.kt)("p",null,"If you do not want the ",(0,a.kt)("inlineCode",{parentName:"p"},"a:")," tagged prefix, you can use ",(0,a.kt)("inlineCode",{parentName:"p"},"untagged-string")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"number"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "idType": "untagged-string"\n}\n')),(0,a.kt)("p",null,"This is currently a project-wide setting and cannot be changed on an entity-by-entity basis."),(0,a.kt)("p",null,"Also note that this ",(0,a.kt)("inlineCode",{parentName:"p"},"idType")," setting controls the ",(0,a.kt)("em",{parentName:"p"},"codegen output"),", but Joist will still look at the database type of each individual entity's ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," column to determine if the SQL values are actually numbers (i.e. auto increment integers) or other types like UUIDs."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Even if you use ",(0,a.kt)("inlineCode",{parentName:"p"},"untagged-string"),"s, currently Joist still manages ids internally as tagged, and so you'll still see a per-entity ",(0,a.kt)("inlineCode",{parentName:"p"},"tag")," established in the ",(0,a.kt)("inlineCode",{parentName:"p"},"joist-config.json")," file, but the tag will be stripped by the ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," getters.")),(0,a.kt)("h3",{id:"contexttype"},(0,a.kt)("inlineCode",{parentName:"h3"},"contextType")),(0,a.kt)("p",null,"This optional key specifies your application specific ",(0,a.kt)("inlineCode",{parentName:"p"},"Context")," type, if you're using that pattern."),(0,a.kt)("p",null,"The expectation is that this will be a request-level ",(0,a.kt)("inlineCode",{parentName:"p"},"Context"),", i.e. it might hold user auth information or other application-specific information."),(0,a.kt)("p",null,"If you pass your request-level ",(0,a.kt)("inlineCode",{parentName:"p"},"Context")," to each ",(0,a.kt)("inlineCode",{parentName:"p"},"EntityManager"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Context } from "src/context";\nimport { EntityManager } from "src/entities";\n\nconst em = new EntityManager(ctx, driver);\n')),(0,a.kt)("p",null,"Then in ",(0,a.kt)("inlineCode",{parentName:"p"},"EntityManager"),"-managed hooks, you'll be able to access the context:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'config.beforeDelete((book, ctx) => {\n  if (!ctx.user.isAdmin) {\n    return "Only admins can delete a book";\n  }\n});\n')),(0,a.kt)("p",null,"And the ",(0,a.kt)("inlineCode",{parentName:"p"},"ctx")," param will be correctly typed to your application's specific ",(0,a.kt)("inlineCode",{parentName:"p"},"Context")," type."),(0,a.kt)("h3",{id:"entitiesdirectory"},(0,a.kt)("inlineCode",{parentName:"h3"},"entitiesDirectory")),(0,a.kt)("p",null,"This controls whether Joist outputs the entity, codegen, and metadata files."),(0,a.kt)("p",null,"The default is ",(0,a.kt)("inlineCode",{parentName:"p"},"./src/entities"),"."),(0,a.kt)("h3",{id:"createflushfunction"},(0,a.kt)("inlineCode",{parentName:"h3"},"createFlushFunction")),(0,a.kt)("p",null,"Joist's preferred approach to testing is to let tests ",(0,a.kt)("inlineCode",{parentName:"p"},"COMMIT")," their code, and then use a ",(0,a.kt)("inlineCode",{parentName:"p"},"flush_database")," stored procedure to very quickly ",(0,a.kt)("inlineCode",{parentName:"p"},"TRUNCATE")," all tables between each test."),(0,a.kt)("p",null,"This ",(0,a.kt)("inlineCode",{parentName:"p"},"flush_database")," stored procedure if created during ",(0,a.kt)("inlineCode",{parentName:"p"},"npm run codegen"),"."),(0,a.kt)("p",null,"If you'd prefer to not use, you can set this to false:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "createFlushFunction": false\n}\n')),(0,a.kt)("p",null,"If you have multiple test databases (i.e. one per Jest work), you can set the parameter to an array of database names:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "createFlushFunction": ["db_test_1", "db_test_2"]\n}\n')),(0,a.kt)("h3",{id:"ignoredtables"},(0,a.kt)("inlineCode",{parentName:"h3"},"ignoredTables")),(0,a.kt)("p",null,"Allows ignoring tables, i.e. not generating TypeScript entities for them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "ignoredTables": ["some_old_thing"]\n}\n')),(0,a.kt)("h3",{id:"timestampcolumns"},(0,a.kt)("inlineCode",{parentName:"h3"},"timestampColumns")),(0,a.kt)("p",null,"Joist will automatically manage columns like ",(0,a.kt)("inlineCode",{parentName:"p"},"Author.created_at")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Author.updated_at"),"."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"timestampColumns")," key lets you configure your schema's conventions for column names."),(0,a.kt)("p",null,"For example the following config looks for ",(0,a.kt)("em",{parentName:"p"},"only")," ",(0,a.kt)("inlineCode",{parentName:"p"},"updated_at")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"created_at")," and requires both column to be present for Joist to consider a database table and entity table:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "timestampFields": {\n    "updatedAt": {\n      "names": ["updated_at"],\n      "required": true\n    },\n    "createdAt": {\n      "names": ["created_at"],\n      "required": true\n    },\n    "deletedAt": {\n      "names": ["deleted_at"],\n      "required": true\n    }\n  }\n}\n')),(0,a.kt)("p",null,"The default configuration is basically:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "timestampFields": {\n    "updatedAt": {\n      "names": ["updated_at", "updatedAt"],\n      "required": false\n    },\n    "createdAt": {\n      "names": ["created_at", "createdAt"],\n      "required": false\n    }\n  }\n}\n')),(0,a.kt)("p",null,"I.e. Joist will look for either ",(0,a.kt)("inlineCode",{parentName:"p"},"updated_at")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"updatedAt")," naming conventions, and will not require the ",(0,a.kt)("inlineCode",{parentName:"p"},"updatedAt")," column be present to consider a table an entity table."),(0,a.kt)("h3",{id:"codegenplugins"},(0,a.kt)("inlineCode",{parentName:"h3"},"codegenPlugins")),(0,a.kt)("p",null,"Allows other functionality to be inserted into the ",(0,a.kt)("inlineCode",{parentName:"p"},"npm run joist-codegen")," pipeline."),(0,a.kt)("p",null,"The current example is an extra GraphQL-specific plugin that creates GraphQL-specific scaffolding/output based on your domain model:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "codegenPlugins": ["joist-graphql-codegen"]\n}\n')),(0,a.kt)("h3",{id:"entities"},(0,a.kt)("inlineCode",{parentName:"h3"},"entities")),(0,a.kt)("p",null,"This is a big section that allows per-entity configuration."),(0,a.kt)("p",null,"There are several sub-keys:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface EntityConfig {\n  tag: string;\n  tableName?: string;\n  fields?: Record<string, FieldConfig>;\n  relations?: Record<string, RelationConfig>;\n  orderBy?: string;\n}\n")),(0,a.kt)("h4",{id:"tag"},(0,a.kt)("inlineCode",{parentName:"h4"},"tag")),(0,a.kt)("p",null,"This controls the tag that Joist uses for each entity. By default, Joist will guess a tag by abbreviating a table name ",(0,a.kt)("inlineCode",{parentName:"p"},"books_reviews")," as the tag ",(0,a.kt)("inlineCode",{parentName:"p"},"br")," and automatically save it in ",(0,a.kt)("inlineCode",{parentName:"p"},"joist-config.json"),". If you'd like a different value, you're free to change it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "entities": {\n    "Author": { "tag": "a" }\n  }\n}\n')),(0,a.kt)("p",null,"Note that you should probably not change the tag name for an entity after it has been deployed to production, b/c the tagged id could exist in external systems, i.e. if you've sent ",(0,a.kt)("inlineCode",{parentName:"p"},'"a:1"')," to a 3rd party system, and then change your tag to ",(0,a.kt)("inlineCode",{parentName:"p"},'"author"'),", you might break an integration that tries to look up the entity by the old ",(0,a.kt)("inlineCode",{parentName:"p"},'"a:1"')," value."),(0,a.kt)("h4",{id:"tablename"},(0,a.kt)("inlineCode",{parentName:"h4"},"tableName")),(0,a.kt)("p",null,"Allows defining specific entity names for tables, for example if you had a ",(0,a.kt)("inlineCode",{parentName:"p"},"tbl_publishers")," table that you wanted to back the ",(0,a.kt)("inlineCode",{parentName:"p"},"Publisher")," entity, then you could setup:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "entities": {\n    "Publisher": { "tableName": "tbl_publishers" }\n  }\n}\n')),(0,a.kt)("p",null,"By default, Joist assumes table names are plural (i.e. ",(0,a.kt)("inlineCode",{parentName:"p"},"publishers"),") and will ",(0,a.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/pluralize"},(0,a.kt)("inlineCode",{parentName:"a"},"singular"))," the name for the entity name (i.e. ",(0,a.kt)("inlineCode",{parentName:"p"},"Publisher"),")."),(0,a.kt)("h3",{id:"entitiesorderby"},(0,a.kt)("inlineCode",{parentName:"h3"},"entities.orderBy")),(0,a.kt)("p",null,"Allows defining a default ",(0,a.kt)("inlineCode",{parentName:"p"},"orderBy")," for the entity, i.e. if you want to always order ",(0,a.kt)("inlineCode",{parentName:"p"},"Publisher")," entities by ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," by default, you could setup:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "entities": {\n    "Publisher": { "orderBy": "name" }\n  }\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"orderBy")," value must be the field name of a primitive, synchronous value on the entity. Or a field name with an ",(0,a.kt)("inlineCode",{parentName:"p"},"ASC")," / ",(0,a.kt)("inlineCode",{parentName:"p"},"DESC")," suffix, i.e. ",(0,a.kt)("inlineCode",{parentName:"p"},'"orderBy": "name DESC"'),"."),(0,a.kt)("p",null,"If unset, Joist will order by ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," by default to ensure deterministic ordering."),(0,a.kt)("h3",{id:"entitiesfields"},(0,a.kt)("inlineCode",{parentName:"h3"},"entities.fields")),(0,a.kt)("p",null,"You can configure primitive fields by setting the camel-cased field name in the entity's ",(0,a.kt)("inlineCode",{parentName:"p"},"fields")," key:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "entities": {\n    "Author": { "fields": { "firstName": {} } }\n  }\n}\n')),(0,a.kt)("p",null,"Within the field literal, these values are supported:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'export interface FieldConfig {\n  derived?: "sync" | "async";\n  protected?: boolean;\n  ignore?: true;\n  superstruct?: string;\n  zodSchema?: string;\n  type?: string;\n}\n')),(0,a.kt)("p",null,"Where:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"derived")," controls whether this field is derived from business logic (...link to docs...)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"protected")," controls whether this is field is ",(0,a.kt)("inlineCode",{parentName:"p"},"protected")," and so can only be accessed internally by the domain model code")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"ignore")," controls whether to ignore the field")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"superstruct")," links to the superstruct type to use for ",(0,a.kt)("a",{parentName:"p",href:"/docs/modeling/jsonb-fields"},(0,a.kt)("inlineCode",{parentName:"a"},"jsonb")," columns"),", i.e. ",(0,a.kt)("inlineCode",{parentName:"p"},"commentStreamReads@src/entities/superstruct"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"zodSchema")," links to the Zod schema to use for ",(0,a.kt)("a",{parentName:"p",href:"/docs/modeling/jsonb-fields"},(0,a.kt)("inlineCode",{parentName:"a"},"jsonb")," columns"),", i.e. ",(0,a.kt)("inlineCode",{parentName:"p"},"CommentStreamReads@src/entities/schemas")," ")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"type")," links to an TypeScript type to use instead of the schema derived one"),(0,a.kt)("p",{parentName:"li"}," Currently, the ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," must be a ",(0,a.kt)("a",{parentName:"p",href:"https://typescript.tv/best-practices/improve-your-type-safety-with-branded-types/"},"branded type")," of the runtime type, b/c Joist will still instantiate the value with whatever it's schema-derived value is."),(0,a.kt)("p",{parentName:"li"}," See ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/stephenh/joist-ts/discussions/674#discussioncomment-6092907"},"this discussion")," for a future ",(0,a.kt)("inlineCode",{parentName:"p"},"serde")," feature that would allow you to instantiate custom runtime values."))),(0,a.kt)("h3",{id:"entitiesrelations"},(0,a.kt)("inlineCode",{parentName:"h3"},"entities.relations")),(0,a.kt)("p",null,"You can configure relations (references and collections to other entities) by setting the camel-cased relation name in the entity's ",(0,a.kt)("inlineCode",{parentName:"p"},"relations")," key:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'export interface RelationConfig {\n  polymorphic?: "notNull" | true;\n  large?: true;\n  orderBy?: string;\n}\n')),(0,a.kt)("p",null,"The supported values are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"polymorphic")," creates this relation as a ",(0,a.kt)("a",{parentName:"li",href:"/docs/modeling/relations#polymorphic-references"},"polymorphic relation"),", which logical combines several physical foreign keys into a single field"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"large")," indicates that a collection is too big to be fully loaded into memory and changes the generated type to ",(0,a.kt)("inlineCode",{parentName:"li"},"LargeCollection"),"  "),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"orderBy")," allows setting an order specific to this collection, the value must be a primitive, synchronous field on the entities within the collection")),(0,a.kt)("h2",{id:"runtime-configuration"},"Runtime Configuration"),(0,a.kt)("p",null,"There are three main things to configure at runtime:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Connection pool"),(0,a.kt)("li",{parentName:"ul"},"Driver"),(0,a.kt)("li",{parentName:"ul"},"EntityManager")),(0,a.kt)("h3",{id:"connection-pool"},"Connection Pool"),(0,a.kt)("p",null,"Your application should have a single global connection pool; currently Joist recommends using ",(0,a.kt)("a",{parentName:"p",href:"http://knexjs.org/"},"knex"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'import { newPgConnectionConfig } from "joist-utils";\n\nconst knex = createKnex({\n  client: "pg",\n  // This will read DATABASE_URL, but you can use whatever config you want, see the knex docs\n  connection: newPgConnectionConfig(),\n  // Setting this is true will `console.log` the SQL statements that Joist executes\n  debug: false,\n  asyncStackTraces: true,\n});\n')),(0,a.kt)("h3",{id:"driver"},"Driver"),(0,a.kt)("p",null,"Joist has a ",(0,a.kt)("inlineCode",{parentName:"p"},"Driver")," interface to support multiple different databases, like Postgres or MySQL or even an experimental in-memory driver. Currently only Postgres is supported."),(0,a.kt)("p",null,"Similar to the knex connection pool, you can create a single global instance of this driver:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const driver = new PostgresDriver(knex);\n")),(0,a.kt)("h4",{id:"idassigner"},"IdAssigner"),(0,a.kt)("p",null,"When creating the ",(0,a.kt)("inlineCode",{parentName:"p"},"PostgresDriver"),", you can pass an ",(0,a.kt)("inlineCode",{parentName:"p"},"IdAssigner")," instance, which currently has three implementations:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"SequenceIdAssigner")," assigns numeric ids from each entity's ",(0,a.kt)("inlineCode",{parentName:"li"},"SEQUENCE")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"RandomUuidAssigner")," assigns random UUIDs if you're using UUID columns"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TestUuidAssigner")," assigns deterministic UUIDs for unit testing")),(0,a.kt)("h3",{id:"entitymanager"},"EntityManager"),(0,a.kt)("p",null,"With the global connection pool and ",(0,a.kt)("inlineCode",{parentName:"p"},"Driver")," instance, you can create per-request ",(0,a.kt)("inlineCode",{parentName:"p"},"EntityManager")," instances:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Your application's per-request Context, if applicable\nconst ctx = {};\nconst em = new EntityManager(ctx, driver);\n")))}u.isMDXComponent=!0}}]);