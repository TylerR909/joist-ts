"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[558],{5318:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7378);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(n),h=i,m=c["".concat(l,".").concat(h)]||c[h]||u[h]||a;return n?r.createElement(m,o(o({ref:t},p),{},{components:n})):r.createElement(m,o({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var d=2;d<a;d++)o[d]=n[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},7649:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var r=n(5773),i=(n(7378),n(5318));const a={title:"Derived Fields",sidebar_position:7},o=void 0,s={unversionedId:"modeling/derived-fields",id:"modeling/derived-fields",title:"Derived Fields",description:"Derived fields are field values (i.e. primitives) that can be calculated from other data within your domain model.",source:"@site/docs/modeling/derived-fields.md",sourceDirName:"modeling",slug:"/modeling/derived-fields",permalink:"/docs/modeling/derived-fields",draft:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/modeling/derived-fields.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{title:"Derived Fields",sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Enums",permalink:"/docs/modeling/enum-tables"},next:{title:"JSONB Fields",permalink:"/docs/modeling/jsonb-fields"}},l={},d=[{value:"Synchronous, Unpersisted Fields",id:"synchronous-unpersisted-fields",level:2},{value:"Synchronous, Persisted Fields",id:"synchronous-persisted-fields",level:2},{value:"Asynchronous, Unpersisted Fields",id:"asynchronous-unpersisted-fields",level:2},{value:"Asynchronous, Persisted Fields",id:"asynchronous-persisted-fields",level:2}],p={toc:d};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Derived fields are field values (i.e. primitives) that can be calculated from other data within your domain model."),(0,i.kt)("p",null,"There are two axis by which to categorize derived fields:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Synchronous vs. Asynchronous"),(0,i.kt)("p",{parentName:"li"},"Synchronous derived fields only rely on other fields/columns within the same entity (i.e. an ",(0,i.kt)("inlineCode",{parentName:"p"},"Author"),"s initials only require knowing the same ",(0,i.kt)("inlineCode",{parentName:"p"},"Author"),"'s ",(0,i.kt)("inlineCode",{parentName:"p"},"firstName")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"lastName"),"), so do not need to load any other entities to calculate their value."),(0,i.kt)("p",{parentName:"li"},"Async derived values do rely on fields from other entities (i.e. an ",(0,i.kt)("inlineCode",{parentName:"p"},"Author"),"'s number of books requires loading the ",(0,i.kt)("inlineCode",{parentName:"p"},"author.books")," one-to-many collection), and so need to load references/collections before calculating their value.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Persisted vs. Unpersisted"),(0,i.kt)("p",{parentName:"li"},"Persisted derived fields have their latest value stored in the database, typically for quick access on summary screens, filtering, or exposing the values to external systems like a data warehouse."),(0,i.kt)("p",{parentName:"li"},"Unpersisted derived fields are not stored in the database, and have their value recalculated every time they're accessed."))),(0,i.kt)("p",null,"And so there are 4 combinations (async vs. sync ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," persisted vs. unpersisted), and Joist has an approach for modeling each combination."),(0,i.kt)("h2",{id:"synchronous-unpersisted-fields"},"Synchronous, Unpersisted Fields"),(0,i.kt)("p",null,"For synchronous, unpersisted fields, you can just implement these as getters in your domain objects:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'export class Author {\n  /** Implements the business logic for an unpersisted derived value. */\n  get fullName(): string {\n    return this.firstName + (this.lastName ? ` ${this.lastName}` : "");\n  }\n}\n')),(0,i.kt)("h2",{id:"synchronous-persisted-fields"},"Synchronous, Persisted Fields"),(0,i.kt)("p",null,"For synchronous, persisted fields, there will be a column in the database to hold the value, i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"authors.initials"),", which you can mark as ",(0,i.kt)("inlineCode",{parentName:"p"},"sync")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"joist-config.json"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "entities": {\n    "Author": {\n      "fields": {\n        "initials": { "derived": "sync" }\n      }\n    }\n  }\n}\n')),(0,i.kt)("p",null,"This will cause the ",(0,i.kt)("inlineCode",{parentName:"p"},"Author.initials")," field to not have a setter, only an ",(0,i.kt)("inlineCode",{parentName:"p"},"abstract")," getter than you must implement:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'export class Author {\n  /** Implements the business logic for a (synchronous) persisted derived value. */\n  get initials(): string {\n    return (this.firstName || "")[0] + (this.lastName !== undefined ? this.lastName[0] : "");\n  }\n}\n')),(0,i.kt)("p",null,"This getter will be automatically called by Joist during any ",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"Author"),", to determine the latest value."),(0,i.kt)("p",null,"Because of this, synchronous persisted derived fields should be cheap to calculate."),(0,i.kt)("h2",{id:"asynchronous-unpersisted-fields"},"Asynchronous, Unpersisted Fields"),(0,i.kt)("p",null,"For async, unpersisted fields, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"hasAsyncProperty"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'export class Author {\n  /** Example of an async property that can be loaded via a populate hint. */\n  readonly numberOfBooks: AsyncProperty<Author, number> = hasAsyncProperty("books", (a) => {\n    return a.books.get.length;\n  });\n}\n')),(0,i.kt)("p",null,"Because it's async, the property must be loaded with a populate hint:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'const a = await em.load(Author, "a:1", "numberOfBooks");\nconsole.log(a.numberOfBooks.get);\n')),(0,i.kt)("h2",{id:"asynchronous-persisted-fields"},"Asynchronous, Persisted Fields"),(0,i.kt)("p",null,"For async, persisted fields, there will be a column in the database to hold the value, i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"authors.number_of_books"),", which you can mark as ",(0,i.kt)("inlineCode",{parentName:"p"},"async")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"joist-config.json"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "entities": {\n    "Author": {\n      "fields": {\n        "numberOfBooks": { "derived": "async" }\n      }\n    }\n  }\n}\n')),(0,i.kt)("p",null,"And then implement a property in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Author")," domain model with the same name:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'import { PersistedAsyncProperty, hasPersistedAsyncProperty } from "joist-orm";\n\nclass Author extends AuthorCodegen {\n  readonly numberOfBooks: PersistedAsyncProperty<Author, number> = hasPersistedAsyncProperty(\n    "numberOfBooks",\n    "books",\n    (author) => author.books.get.length,\n  );\n}\n')),(0,i.kt)("p",null,"The readonly property must be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"PersistedAsyncProperty"),", which has two type arguments:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The type of the entity"),(0,i.kt)("li",{parentName:"ol"},"The type of the property")),(0,i.kt)("p",null,"The value is the result of the method ",(0,i.kt)("inlineCode",{parentName:"p"},"hasPersistedAsyncProperty")," that has three arguments:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fieldName"),": The name of the property, this should match the name of the field in the entity and in joist-config.json."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reactiveHint"),": The name of the fields on the entity that should trigger a recalculation of the derived field. This can be a string(",(0,i.kt)("inlineCode",{parentName:"li"},'"books"'),"), an array of strings (",(0,i.kt)("inlineCode",{parentName:"li"},'["books", "someOtherRelationship"]'),") or an object of nested relationships (",(0,i.kt)("inlineCode",{parentName:"li"},'{books: ["reviews"]}'),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fn")," The function that calculates the value of the derived field. This function will be called with the entity as the only argument. All of the fields in the reactiveHint will be loaded before this function is called and can be accessed syncronously using ",(0,i.kt)("inlineCode",{parentName:"li"},"get"),".")),(0,i.kt)("p",null,"Joist will call this lambda:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"When the ",(0,i.kt)("inlineCode",{parentName:"li"},"Author")," is initially created"),(0,i.kt)("li",{parentName:"ol"},"When the ",(0,i.kt)("inlineCode",{parentName:"li"},"Author")," is updated"),(0,i.kt)("li",{parentName:"ol"},"Whenever one of the ",(0,i.kt)("inlineCode",{parentName:"li"},"Author"),"'s books changes"),(0,i.kt)("li",{parentName:"ol"},"When a ",(0,i.kt)("inlineCode",{parentName:"li"},"Book")," is created or deleted for the ",(0,i.kt)("inlineCode",{parentName:"li"},"Author"))),(0,i.kt)("p",null,"For example, in this scenario:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'const a1 = await em.load(Author, "a:1");\nconst a2 = await em.load(Author, "a:2");\n\nconst b1 = em.create(Book, { author: a1 });\n\nem.flush(); // automatically updates a1.numberOfBooks\n')))}u.isMDXComponent=!0}}]);